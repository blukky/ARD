#Connections
#MPU6050 - Raspberry pi
#VCC - 5V  (2 or 4 Board)
#GND - GND (6 - Board)
#SCL - SCL (5 - Board)
#SDA - SDA (3 - Board)


from Kalman import KalmanAngle
import smbus			#import SMBus module of I2C
import time
import math
from threading import Thread



class MPU6050(Thread):
    PWR_MGMT_1   = 0x6B
    SMPLRT_DIV   = 0x19
    CONFIG       = 0x1A
    GYRO_CONFIG  = 0x1B
    INT_ENABLE   = 0x38
    ACCEL_XOUT_H = 0x3B
    ACCEL_YOUT_H = 0x3D
    ACCEL_ZOUT_H = 0x3F
    GYRO_XOUT_H  = 0x43
    GYRO_YOUT_H  = 0x45
    GYRO_ZOUT_H  = 0x47

    #radToDeg = 180 / math.pi


    def __init__(self, pin: int = None):
        super(MPU6050, self).__init__()
        self.pin = pin if not pin is None else 0x68
        self.bus = smbus.SMBus(1)
        self.kalmanX = KalmanAngle()
        self.kalmanY = KalmanAngle()

        self.RestrictPitch = True	#Comment out to restrict roll to Â±90deg instead - please read: http://www.freescale.com/files/sensors/doc/app_note/AN3461.pdf
        self.currentPitch = 0
        self.currentRoll = 0
        self.init_settings()

        self.isStart = True

    def init_settings(self):
        #write to sample rate register
        self.bus.write_byte_data(self.pin, MPU6050.SMPLRT_DIV, 7)

        #Write to power management register
        self.bus.write_byte_data(self.pin, MPU6050.PWR_MGMT_1, 1)

	#Write to Configuration register
	#Setting DLPF (last three bit of 0X1A to 6 i.e '110' It removes the noise due to vibration.) https://ulrichbuschbaum.wordpress.com/2015/01/18/using-the-mpu6050s-dlpf/
        self.bus.write_byte_data(self.pin, MPU6050.CONFIG, int('0000110',2))

	#Write to Gyro configuration register
        self.bus.write_byte_data(self.pin, MPU6050.GYRO_CONFIG, 24)

	#Write to interrupt enable register
        self.bus.write_byte_data(self.pin, MPU6050.INT_ENABLE, 1)

    def read_raw_data(self, addr):
	#Accelero and Gyro value are 16-bit
        high = self.bus.read_byte_data(self.pin, addr)
        low = self.bus.read_byte_data(self.pin, addr+1)

        #concatenate higher and lower value
        value = ((high << 8) | low)

        #to get signed value from mpu6050
        if(value > 32768):
                value = value - 65536
        return value

    def dist(self,a, b):
        return math.sqrt(a**2 + b**2)


    def calcAngle(self, accX, accY, accZ):
        #return math.degrees(math.atan2(accY, accZ)), math.degrees(math.atan2(accX, accZ))
        #if (self.RestrictPitch):
        #    pitch = math.degrees(math.atan2(accY,accZ))
        #    roll = math.degrees(math.atan2(accX, self.dist(accY, accZ)))
        #else:
        #    pitch = math.degrees(math.atan2(accY, self.dist(accX, accZ)))
        #    roll = math.degrees(math.atan2(-accX,accZ))
        #return pitch, roll
        roll = math.atan()


    def init_angle(self, accel):
        pitch, roll = self.calcAngle(**accel)
        self.kalmanX.setAngle(pitch)
        self.kalmanY.setAngle(roll)
        return pitch, roll

    def get_accelerometer_data(self):
        accX = self.read_raw_data(MPU6050.ACCEL_XOUT_H)
        accY = self.read_raw_data(MPU6050.ACCEL_YOUT_H)
        accZ = self.read_raw_data(MPU6050.ACCEL_ZOUT_H)
        return {"accX": accX/16384.0, "accY": accY/16384.0, "accZ": accZ/16384.0}


    def get_gyroscope_data(self):
        gyroX = self.read_raw_data(MPU6050.GYRO_XOUT_H)
        gyroY = self.read_raw_data(MPU6050.GYRO_YOUT_H)
        gyroZ = self.read_raw_data(MPU6050.GYRO_ZOUT_H)
        return {"gyroX": gyroX, "gyroY": gyroY, "gyroZ": gyroZ}



    def run(self):
        accel = self.get_accelerometer_data()
        pitch, roll = self.init_angle(accel)
        gyroXAngle = pitch
        gyroYAngle = roll
        compAngleX = pitch
        compAngleY = roll
        timer = time.time()
        while self.isStart:
            accel = self.get_accelerometer_data()
            gyro = self.get_gyroscope_data()
            dt = time.time() - timer
            timer = time.time()
            pitch, roll = self.calcAngle(**accel)
            gyroXRate = gyro.get("gyroX")/131
            gyroYRate = gyro.get("gyroY")/131
            self.currentPitch = pitch
            self.currentRoll = roll
            if (self.RestrictPitch):
                if((pitch < -90 and self.currentPitch >90) or (pitch > 90 and self.currentPitch < -90)):
                    self.kalmanX.setAngle(pitch)
                    complAngleX = pitch
                    self.currentRoll   = pitch
                    gyroXAngle  = pitch
                else:
                    self.currentPitch = self.kalmanX.getAngle(pitch,gyroXRate,dt)
                if(abs(self.currentRoll)>90):
                    gyroYRate  = -gyroYRate
                    self.currentRoll  = self.kalmanY.getAngle(roll,gyroYRate,dt)
            else:
                if((roll < -90 and self.currentRoll >90) or (roll > 90 and self.currentRoll < -90)):
                    self.kalmanY.setAngle(roll)
                    complAngleY = roll
                    self.currentRoll   = roll
                    gyroYAngle  = roll
                else:
                    self.currentRoll = self.kalmanY.getAngle(roll,gyroYRate,dt)
                if(abs(self.currentPitch)>90):
                    gyroXRate  = -gyroXRate
                    self.currentPitch = self.kalmanX.getAngle(pitch,gyroXRate,dt)

		#angle = (rate of change of angle) * change in time
            gyroXAngle = gyroXRate * dt
            gyroYAngle = gyroYAngle * dt

		#compAngle = constant * (old_compAngle + angle_obtained_from_gyro) + constant * angle_obtained from accelerometer
            compAngleX = 0.93 * (compAngleX + gyroXRate * dt) + 0.07 * pitch
            compAngleY = 0.93 * (compAngleY + gyroYRate * dt) + 0.07 * roll
            if ((gyroXAngle < -180) or (gyroXAngle > 180)):
                gyroXAngle = self.currentPitch
            if ((gyroYAngle < -180) or (gyroYAngle > 180)):
                gyroYAngle = self.currentRoll

            print("Angle X: " + str(self.currentPitch)+"   " +"Angle Y: " + str(self.currentRoll))
	    #print(str(roll)+"  "+str(gyroXAngle)+"  "+str(compAngleX)+"  "+str(kalAngleX)+"  "+str(pitch)+"  "+str(gyroYAngle)+"  "+str(compAngleY)+"  "+str(kalAngleY))
            time.sleep(0.005)
